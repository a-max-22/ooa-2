## Пример усиления предусловия 
Рассмотрим класс, реализующий структуру данных "дерево" (Tree). Если от класса tree унаследовать класс "двоичное дерево" (BinaryTree), то мы получим усиление предусловия для операции добавления дочернего узла. Так, для обычного дерева эта операция всегда успешна, в то время как для двоичного предусловие состоит в том, что у родителя не должно быть более одной дочерней вершины. 
Таким образом, следующий код: 
```python
def proc(t:Tree):
    ...
    t.add_child(node, new_node)
```
может не отработать ожидаемым образом, если в качестве параметра вместо t передать экземпляр BinaryTree.  


## Пример ослабления постусловия
Рассмотрим еще одну гипотетическую иерархию классов Iterator -> CircularIterator, каждый из которых 
предназначен для обхода коллекций. Предположим, что в данных классах имеется метод advance(), который
сдвигает внутреннее положение к следующему элементу, а также метод is_end_reached(), который возвращает True, если достигнут конец коллекции. При этом, логика CircularIterator такова, что is_end_reached всегда True (для непустой коллекции), т.е. внутренний указатель при достижении конца коллекции переходит к следующему элементу. 

Предусловие ослабляется: для Iterator это  коллекция непуста и текущий не  указывает на последний элемент. Для CircularIterator - коллекция непуста.
Постусловие тажке  ослаблятся:  для Iterator: внутренний указатель указывает на следующий элемент, либо элемент за пределом последнего (в таком случае is_end_reached вернет True). Для CircularIterator внутренний указатель указывает на следующий элемент, либо на первый, is_end_reached всегда True.

Таким образом, цикл в нижеприведенной функции никогда не завершится, если в качестве параметра it передать экземпляр CircularIerator:
 
 ```python
def proc(it:Iterator):
    ...
    while(not it.is_end_reached()):
        ...
        
```
